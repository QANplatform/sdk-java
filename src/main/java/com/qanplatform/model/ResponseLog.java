/*
 * QAN AutoApi
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.qanplatform.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.qanplatform.invoker.JSON;

/**
 * ResponseLog
 */

public class ResponseLog {
  public static final String SERIALIZED_NAME_ADDRESS = "Address";
  @SerializedName(SERIALIZED_NAME_ADDRESS)
  private String address;

  public static final String SERIALIZED_NAME_BLOCK_HASH = "BlockHash";
  @SerializedName(SERIALIZED_NAME_BLOCK_HASH)
  private String blockHash;

  public static final String SERIALIZED_NAME_BLOCK_NUMBER = "BlockNumber";
  @SerializedName(SERIALIZED_NAME_BLOCK_NUMBER)
  private String blockNumber;

  public static final String SERIALIZED_NAME_DATA = "Data";
  @SerializedName(SERIALIZED_NAME_DATA)
  private String data;

  public static final String SERIALIZED_NAME_LOG_INDEX = "LogIndex";
  @SerializedName(SERIALIZED_NAME_LOG_INDEX)
  private String logIndex;

  public static final String SERIALIZED_NAME_REMOVED = "Removed";
  @SerializedName(SERIALIZED_NAME_REMOVED)
  private Boolean removed;

  public static final String SERIALIZED_NAME_TOPICS = "Topics";
  @SerializedName(SERIALIZED_NAME_TOPICS)
  private List<String> topics = new ArrayList<>();

  public static final String SERIALIZED_NAME_TRANSACTION_HASH = "TransactionHash";
  @SerializedName(SERIALIZED_NAME_TRANSACTION_HASH)
  private String transactionHash;

  public static final String SERIALIZED_NAME_TRANSACTION_INDEX = "TransactionIndex";
  @SerializedName(SERIALIZED_NAME_TRANSACTION_INDEX)
  private String transactionIndex;

  public ResponseLog() {
  }

  public ResponseLog address(String address) {
    this.address = address;
    return this;
  }

  /**
   * An address from which this log originated
   * @return address
   */
  @javax.annotation.Nonnull
  public String getAddress() {
    return address;
  }

  public void setAddress(String address) {
    this.address = address;
  }


  public ResponseLog blockHash(String blockHash) {
    this.blockHash = blockHash;
    return this;
  }

  /**
   * The hash of the block where this log was in. null when its a pending log
   * @return blockHash
   */
  @javax.annotation.Nullable
  public String getBlockHash() {
    return blockHash;
  }

  public void setBlockHash(String blockHash) {
    this.blockHash = blockHash;
  }


  public ResponseLog blockNumber(String blockNumber) {
    this.blockNumber = blockNumber;
    return this;
  }

  /**
   * The block number where this log was in. null when its a pending log
   * @return blockNumber
   */
  @javax.annotation.Nullable
  public String getBlockNumber() {
    return blockNumber;
  }

  public void setBlockNumber(String blockNumber) {
    this.blockNumber = blockNumber;
  }


  public ResponseLog data(String data) {
    this.data = data;
    return this;
  }

  /**
   * It contains one or more 32 Bytes non-indexed arguments of the log
   * @return data
   */
  @javax.annotation.Nonnull
  public String getData() {
    return data;
  }

  public void setData(String data) {
    this.data = data;
  }


  public ResponseLog logIndex(String logIndex) {
    this.logIndex = logIndex;
    return this;
  }

  /**
   * The integer of the log index position in the block. null when its a pending log
   * @return logIndex
   */
  @javax.annotation.Nullable
  public String getLogIndex() {
    return logIndex;
  }

  public void setLogIndex(String logIndex) {
    this.logIndex = logIndex;
  }


  public ResponseLog removed(Boolean removed) {
    this.removed = removed;
    return this;
  }

  /**
   * It is true when the log was removed due to a chain reorganization, and false if it&#39;s a valid log
   * @return removed
   */
  @javax.annotation.Nonnull
  public Boolean getRemoved() {
    return removed;
  }

  public void setRemoved(Boolean removed) {
    this.removed = removed;
  }


  public ResponseLog topics(List<String> topics) {
    this.topics = topics;
    return this;
  }

  public ResponseLog addTopicsItem(String topicsItem) {
    if (this.topics == null) {
      this.topics = new ArrayList<>();
    }
    this.topics.add(topicsItem);
    return this;
  }

  /**
   * An array of zero to four 32 Bytes DATA of indexed log arguments. In Solidity, the first topic is the hash of the signature of the event (e.g. Deposit(address, bytes32, uint256)), except you declare the event with the anonymous specifier
   * @return topics
   */
  @javax.annotation.Nonnull
  public List<String> getTopics() {
    return topics;
  }

  public void setTopics(List<String> topics) {
    this.topics = topics;
  }


  public ResponseLog transactionHash(String transactionHash) {
    this.transactionHash = transactionHash;
    return this;
  }

  /**
   * The hash of the transactions this log was created from. null when its a pending log
   * @return transactionHash
   */
  @javax.annotation.Nullable
  public String getTransactionHash() {
    return transactionHash;
  }

  public void setTransactionHash(String transactionHash) {
    this.transactionHash = transactionHash;
  }


  public ResponseLog transactionIndex(String transactionIndex) {
    this.transactionIndex = transactionIndex;
    return this;
  }

  /**
   * The integer of the transaction&#39;s index position that the log was created from. null when it&#39;s a pending log
   * @return transactionIndex
   */
  @javax.annotation.Nullable
  public String getTransactionIndex() {
    return transactionIndex;
  }

  public void setTransactionIndex(String transactionIndex) {
    this.transactionIndex = transactionIndex;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ResponseLog responseLog = (ResponseLog) o;
    return Objects.equals(this.address, responseLog.address) &&
        Objects.equals(this.blockHash, responseLog.blockHash) &&
        Objects.equals(this.blockNumber, responseLog.blockNumber) &&
        Objects.equals(this.data, responseLog.data) &&
        Objects.equals(this.logIndex, responseLog.logIndex) &&
        Objects.equals(this.removed, responseLog.removed) &&
        Objects.equals(this.topics, responseLog.topics) &&
        Objects.equals(this.transactionHash, responseLog.transactionHash) &&
        Objects.equals(this.transactionIndex, responseLog.transactionIndex);
  }

  @Override
  public int hashCode() {
    return Objects.hash(address, blockHash, blockNumber, data, logIndex, removed, topics, transactionHash, transactionIndex);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ResponseLog {\n");
    sb.append("    address: ").append(toIndentedString(address)).append("\n");
    sb.append("    blockHash: ").append(toIndentedString(blockHash)).append("\n");
    sb.append("    blockNumber: ").append(toIndentedString(blockNumber)).append("\n");
    sb.append("    data: ").append(toIndentedString(data)).append("\n");
    sb.append("    logIndex: ").append(toIndentedString(logIndex)).append("\n");
    sb.append("    removed: ").append(toIndentedString(removed)).append("\n");
    sb.append("    topics: ").append(toIndentedString(topics)).append("\n");
    sb.append("    transactionHash: ").append(toIndentedString(transactionHash)).append("\n");
    sb.append("    transactionIndex: ").append(toIndentedString(transactionIndex)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("Address");
    openapiFields.add("BlockHash");
    openapiFields.add("BlockNumber");
    openapiFields.add("Data");
    openapiFields.add("LogIndex");
    openapiFields.add("Removed");
    openapiFields.add("Topics");
    openapiFields.add("TransactionHash");
    openapiFields.add("TransactionIndex");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("Address");
    openapiRequiredFields.add("BlockHash");
    openapiRequiredFields.add("BlockNumber");
    openapiRequiredFields.add("Data");
    openapiRequiredFields.add("LogIndex");
    openapiRequiredFields.add("Removed");
    openapiRequiredFields.add("Topics");
    openapiRequiredFields.add("TransactionHash");
    openapiRequiredFields.add("TransactionIndex");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ResponseLog
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ResponseLog.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ResponseLog is not found in the empty JSON string", ResponseLog.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ResponseLog.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ResponseLog` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ResponseLog.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("Address").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Address` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Address").toString()));
      }
      if ((jsonObj.get("BlockHash") != null && !jsonObj.get("BlockHash").isJsonNull()) && !jsonObj.get("BlockHash").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `BlockHash` to be a primitive type in the JSON string but got `%s`", jsonObj.get("BlockHash").toString()));
      }
      if ((jsonObj.get("BlockNumber") != null && !jsonObj.get("BlockNumber").isJsonNull()) && !jsonObj.get("BlockNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `BlockNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("BlockNumber").toString()));
      }
      if (!jsonObj.get("Data").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Data` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Data").toString()));
      }
      if ((jsonObj.get("LogIndex") != null && !jsonObj.get("LogIndex").isJsonNull()) && !jsonObj.get("LogIndex").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `LogIndex` to be a primitive type in the JSON string but got `%s`", jsonObj.get("LogIndex").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("Topics") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("Topics").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `Topics` to be an array in the JSON string but got `%s`", jsonObj.get("Topics").toString()));
      }
      if ((jsonObj.get("TransactionHash") != null && !jsonObj.get("TransactionHash").isJsonNull()) && !jsonObj.get("TransactionHash").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TransactionHash` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TransactionHash").toString()));
      }
      if ((jsonObj.get("TransactionIndex") != null && !jsonObj.get("TransactionIndex").isJsonNull()) && !jsonObj.get("TransactionIndex").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TransactionIndex` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TransactionIndex").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ResponseLog.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ResponseLog' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ResponseLog> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ResponseLog.class));

       return (TypeAdapter<T>) new TypeAdapter<ResponseLog>() {
           @Override
           public void write(JsonWriter out, ResponseLog value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ResponseLog read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ResponseLog given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ResponseLog
   * @throws IOException if the JSON string is invalid with respect to ResponseLog
   */
  public static ResponseLog fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ResponseLog.class);
  }

  /**
   * Convert an instance of ResponseLog to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

